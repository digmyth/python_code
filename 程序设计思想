## 思想1：Tornado实现session
Tornado没有session功能，我们可以自己写程序实现，真正代码太多不在这里展开，下面是实现思路代码

class A():
    def __init__(self):
        self.name = {}
        self.initialize()

class Foo():
    def __init__(self,handler=None):
        self.data = handler.name

    def __getitem__(self, item):
        return self.data.get(item)

    def __setitem__(self, key, value):
        self.data[key] = value

    def __delitem__(self, key):
        pass

class B(A):
    def initialize(self):
        print('initialize')
        self.session = Foo(self)

    def get(self):
        self.session['user'] = 'wxq'
        print(self.session['user'])
obj = B()
obj.get()

思想2： import实现单例模式



思想3：

程序单例模式有多种： 
1 借住import
借住import实现单例模式是最常见的

2 写类实现
class Foo():
    instance =None

    @staticmethod
    def get_instance():
        if not Foo.instance:
            Foo.instance=Foo()
        return Foo.instance

obj1 = Foo.get_instance()
obj2 = Foo.get_instance()
print(obj1,obj2)


基于这种模式的变型
class Foo():
    instance = None
    @classmethod
    def get_obj(cls):
        if not Foo.instance:
            cls.instance = cls()
        return cls.instance

def Bar():
    return Foo.get_obj()

a=Bar()
b=Bar()
print(a,b)




3  改写object.__new__方法实现单例

class Foo(object):
    instance = None

    def __init__(self):
        self.name = 'wxq'
        print(Foo.instance.name)
        
    def __new__(cls, *args, **kwargs): # 其实是改写了object.__new__方法实现单例
        if Foo.instance:
            return Foo.instance
        else:
             Foo.instance = object.__new__(cls, *args, **kwargs)   
             #Foo.instance.name此时还没有值
             return Foo.instance

obj1 = Foo()
obj2 = Foo()
print(id(obj1),id(obj2))

 object.__new__方法是Foo()对象实例化产生对象地址，并未赋值也未实例化完成，返回值继续交给__init__()方法赋值完成实例化F()
 

## 思想4：接口与抽像类

from abc import ABCMeta,abstractmethod

class Foo(metaclass=ABCMeta):
    @abstractmethod
    def exec(self):
        pass

class C1(Foo):
    def exec(self):
        pass

    def f1(self):
        print("f1 ..")

obj1 = C1()
obj1.f1()

class Foo():
    def read(self):
        raise NotImplementedError("required read() method for subclass")

    def write(self):
        print("write...")

class Bar(Foo):
    def read(self):
        print(123)

obj = Bar()
obj.read()

# class interface Foo():
#     pass


思想5：

思想6：


思想7：


思想8：

思想9：


思想10：


思想11：



思想12：

思想13：


思想14： 


思想15：

思想16：

思想17：

思想18：

